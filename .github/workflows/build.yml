name: Build and Release PDF Metadata Tool

on:
  push:
    paths:
      - 'client.py'
    branches: [ main ]
  workflow_dispatch:
    inputs:
      build_client:
        description: 'Build client executable'
        required: false
        default: 'true'
      version_tag:
        description: 'Version tag for release'
        required: false
        default: ''

env:
  PYTHON_VERSION: '3.11'
  APP_NAME: 'PDF-Metadata-Tool'

jobs:
  build:
    name: Build PDF Metadata Tool Executable
    runs-on: windows-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
          
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyinstaller
        pip install aiohttp aiofiles psutil requests
        echo "Dependencies installed successfully"
        
    - name: Verify client.py exists
      run: |
        if (Test-Path "client.py") {
          Write-Host "‚úÖ client.py found"
          Get-Content client.py -Head 5
        } else {
          Write-Host "‚ùå client.py not found"
          exit 1
        }
        
    - name: Extract version from client.py
      id: extract_version
      run: |
        $content = Get-Content client.py -Raw
        if ($content -match 'VERSION\s*=\s*["\']([^"\']+)["\']') {
          $version = $matches[1]
          Write-Host "Extracted version: $version"
          echo "version=$version" >> $env:GITHUB_OUTPUT
        } else {
          $timestamp = Get-Date -Format "yyyy.MM.dd.HHmm"
          $version = "v$timestamp"
          Write-Host "No version found, using timestamp: $version"
          echo "version=$version" >> $env:GITHUB_OUTPUT
        }
        
    - name: Create application icon (optional)
      run: |
        # Create a simple icon file if it doesn't exist
        $iconPath = "app_icon.ico"
        if (-not (Test-Path $iconPath)) {
          Write-Host "Creating default application icon..."
          # You can add your custom icon creation logic here
          # For now, we'll build without an icon
        }
        
    - name: Build executable with PyInstaller
      run: |
        Write-Host "üî® Building executable..."
        
        # Create build directory
        if (-not (Test-Path "dist")) {
          New-Item -ItemType Directory -Path "dist"
        }
        
        # Build command
        $buildArgs = @(
          "--onefile",
          "--noconsole",
          "--name", "${{ env.APP_NAME }}-v${{ steps.extract_version.outputs.version }}",
          "--distpath", "dist",
          "--workpath", "build",
          "--specpath", "build"
        )
        
        # Add icon if exists
        if (Test-Path "app_icon.ico") {
          $buildArgs += "--icon", "app_icon.ico"
        }
        
        # Add hidden imports for common libraries
        $hiddenImports = @(
          "aiohttp", "aiofiles", "asyncio", "json", "hashlib",
          "platform", "subprocess", "pathlib", "tempfile",
          "zipfile", "shutil", "logging", "threading"
        )
        
        foreach ($import in $hiddenImports) {
          $buildArgs += "--hidden-import", $import
        }
        
        # Add the main script
        $buildArgs += "client.py"
        
        Write-Host "PyInstaller arguments:"
        $buildArgs | ForEach-Object { Write-Host "  $_" }
        
        pyinstaller @buildArgs
        
        Write-Host "‚úÖ Build completed"
        
    - name: Verify build output
      run: |
        $exePath = "dist/${{ env.APP_NAME }}-v${{ steps.extract_version.outputs.version }}.exe"
        if (Test-Path $exePath) {
          $fileInfo = Get-Item $exePath
          Write-Host "‚úÖ Executable created successfully:"
          Write-Host "   Path: $($fileInfo.FullName)"
          Write-Host "   Size: $([math]::Round($fileInfo.Length / 1MB, 2)) MB"
          Write-Host "   Created: $($fileInfo.CreationTime)"
        } else {
          Write-Host "‚ùå Executable not found at expected path: $exePath"
          Write-Host "Contents of dist directory:"
          Get-ChildItem -Path "dist" -Recurse | ForEach-Object { Write-Host "  $($_.FullName)" }
          exit 1
        }
        
    - name: Test executable (basic check)
      run: |
        $exePath = "dist/${{ env.APP_NAME }}-v${{ steps.extract_version.outputs.version }}.exe"
        Write-Host "üß™ Testing executable..."
        
        # Quick test to ensure the executable starts (it should exit quickly in build mode)
        try {
          $process = Start-Process -FilePath $exePath -ArgumentList "--build" -Wait -PassThru -WindowStyle Hidden
          if ($process.ExitCode -eq 0) {
            Write-Host "‚úÖ Executable test passed"
          } else {
            Write-Host "‚ö†Ô∏è Executable test returned exit code: $($process.ExitCode)"
          }
        } catch {
          Write-Host "‚ö†Ô∏è Executable test failed: $_"
          # Don't fail the build for test issues
        }
        
    - name: Create release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ steps.extract_version.outputs.version }}
        release_name: PDF Metadata Tool v${{ steps.extract_version.outputs.version }}
        body: |
          ## PDF Metadata Tool Professional v${{ steps.extract_version.outputs.version }}
          
          üîê **Enterprise-grade PDF metadata restoration with secure licensing**
          
          ### üöÄ Features
          - Advanced PDF metadata processing engine
          - Hardware-locked license validation  
          - Automatic update notifications
          - Professional Material Design UI
          - Real-time progress tracking
          - Enhanced error handling and logging
          
          ### üìã Requirements
          - Windows 10/11 (64-bit)
          - Valid license key from administrator
          - Internet connection for license validation
          
          ### üîß Installation
          1. Download the executable below
          2. Run the application 
          3. Enter your license key when prompted
          4. Place PDF files in the 'original' folder
          5. Processed files will appear in 'processed' folder
          
          ### üìß Support
          For licensing and technical support, contact: halexandros25@gmail.com
          Include your Hardware ID when requesting a license.
          
          ### üîê License Server
          This client connects to: https://pdf-license-server-dmyx.onrender.com
          
          ---
          **Built on:** ${{ github.run_started_at }}  
          **Commit:** ${{ github.sha }}  
          **Build #:** ${{ github.run_number }}
        draft: false
        prerelease: false
        
    - name: Upload release asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: dist/${{ env.APP_NAME }}-v${{ steps.extract_version.outputs.version }}.exe
        asset_name: ${{ env.APP_NAME }}-v${{ steps.extract_version.outputs.version }}.exe
        asset_content_type: application/octet-stream
        
    - name: Update license server
      run: |
        Write-Host "üì° Notifying license server of new release..."
        
        $releaseData = @{
          version = "v${{ steps.extract_version.outputs.version }}"
          download_url = "${{ steps.create_release.outputs.html_url }}"
          release_date = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ssZ")
          build_number = "${{ github.run_number }}"
          commit_sha = "${{ github.sha }}"
        } | ConvertTo-Json
        
        try {
          # You can add a webhook call to your license server here if needed
          # Invoke-RestMethod -Uri "https://your-license-server.com/api/release-notification" -Method POST -Body $releaseData -ContentType "application/json"
          Write-Host "‚úÖ Release notification completed"
        } catch {
          Write-Host "‚ö†Ô∏è Release notification failed: $_"
          # Don't fail the build for notification issues
        }
        
    - name: Cleanup build artifacts
      run: |
        Write-Host "üßπ Cleaning up build artifacts..."
        if (Test-Path "build") {
          Remove-Item -Path "build" -Recurse -Force
          Write-Host "‚úÖ Build directory cleaned"
        }
        
    - name: Build summary
      run: |
        Write-Host ""
        Write-Host "üéâ BUILD COMPLETED SUCCESSFULLY!"
        Write-Host "=================================="
        Write-Host "Version: v${{ steps.extract_version.outputs.version }}"
        Write-Host "Release: ${{ steps.create_release.outputs.html_url }}"
        Write-Host "Download: Direct link available in release"
        Write-Host "Size: $(Get-Item "dist/${{ env.APP_NAME }}-v${{ steps.extract_version.outputs.version }}.exe" | ForEach-Object { [math]::Round($_.Length / 1MB, 2) }) MB"
        Write-Host ""
        Write-Host "üîó Users can now download the latest version!"
        Write-Host "üì± Existing clients will receive automatic update notifications"
        Write-Host ""

  notify_completion:
    name: Notify Build Completion  
    runs-on: ubuntu-latest
    needs: build
    if: always()
    
    steps:
    - name: Notify success
      if: needs.build.result == 'success'
      run: |
        echo "‚úÖ PDF Metadata Tool build completed successfully!"
        echo "üöÄ New release is now available for download"
        echo "üì± Clients will receive automatic update notifications"
        
    - name: Notify failure
      if: needs.build.result == 'failure'
      run: |
        echo "‚ùå PDF Metadata Tool build failed!"
        echo "üîç Check the build logs for details"
        echo "üõ†Ô∏è Manual intervention may be required"
