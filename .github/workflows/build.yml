name: Build Client EXE

on:
  push:
    paths:
      - 'client.py'
    branches:
      - main
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v2.3.0)'
        required: false
        default: ''

# Add permissions for GitHub token
permissions:
  contents: write
  packages: write
  actions: read

jobs:
  build:
    runs-on: windows-latest
    
    # Set environment variables for build detection
    env:
      CI: true
      GITHUB_ACTIONS: true
      BUILD_MODE: true
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyinstaller
        pip install aiohttp aiofiles requests psutil cryptography pywin32
        
        # Updated PDF dependencies
        pip install pillow PyPDF2 pypdf pymupdf reportlab urllib3 certifi
        pip install packaging setuptools wheel
        
        echo "‚úÖ All dependencies installed successfully"

    - name: Verify client.py exists
      run: |
        if (Test-Path "client.py") {
          echo "‚úÖ client.py found"
          $size = (Get-Item "client.py").Length
          echo "üìÑ File size: $([math]::Round($size / 1KB, 2)) KB"
        } else {
          echo "‚ùå client.py not found!"
          exit 1
        }
      shell: pwsh

    - name: Generate version
      id: version
      run: |
        if ("${{ github.event.inputs.version }}" -ne "") {
          echo "VERSION=${{ github.event.inputs.version }}" >> $env:GITHUB_OUTPUT
          echo "üè∑Ô∏è Using manual version: ${{ github.event.inputs.version }}"
        } else {
          $date = Get-Date -Format "yyyy.MM.dd"
          $run = "${{ github.run_number }}"
          $version = "v$date.$run"
          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          echo "üè∑Ô∏è Auto-generated version: $version"
        }
      shell: pwsh

    - name: Update version in client.py
      run: |
        if (Test-Path "client.py") {
          $content = Get-Content client.py -Raw -Encoding UTF8
          
          # Update version strings
          $content = $content -replace 'VERSION\s*=\s*"[^"]*"', 'VERSION = "${{ steps.version.outputs.VERSION }}"'
          $content = $content -replace '__version__\s*=\s*"[^"]*"', '__version__ = "${{ steps.version.outputs.VERSION }}"'
          
          Set-Content client.py $content -Encoding UTF8
          echo "‚úÖ Updated version in file: ${{ steps.version.outputs.VERSION }}"
        }
      shell: pwsh

    - name: Test client.py in build mode
      run: |
        echo "üß™ Testing client.py in BUILD MODE..."
        # This should show build mode output
        python client.py
      shell: pwsh
      env:
        BUILD_MODE: true

    - name: Build EXE with PyInstaller
      run: |
        echo "üöÄ Building production executable..."
        
        $exeName = "PDF-Metadata-Tool-${{ steps.version.outputs.VERSION }}"
        echo "üèóÔ∏è Building: $exeName"
        
        # Create production executable (without build mode flags)
        pyinstaller --onefile `
          --name $exeName `
          --console `
          --hidden-import=aiohttp `
          --hidden-import=aiofiles `
          --hidden-import=asyncio `
          --hidden-import=requests `
          --hidden-import=psutil `
          --hidden-import=cryptography `
          --hidden-import=pkg_resources.extern `
          --hidden-import=win32api `
          --hidden-import=win32con `
          --hidden-import=win32gui `
          --hidden-import=pywintypes `
          --hidden-import=win32file `
          --hidden-import=win32security `
          --hidden-import=PIL `
          --hidden-import=PIL.Image `
          --hidden-import=PyPDF2 `
          --hidden-import=pypdf `
          --hidden-import=fitz `
          --hidden-import=urllib3 `
          --hidden-import=certifi `
          --hidden-import=packaging `
          --collect-submodules=cryptography `
          --collect-submodules=win32api `
          --collect-submodules=PyPDF2 `
          --collect-submodules=pypdf `
          --collect-all=PIL `
          --add-data="C:\hostedtoolcache\windows\Python\3.11.9\x64\Lib\site-packages\certifi\cacert.pem;certifi" `
          --noupx `
          client.py
          
        if ($LASTEXITCODE -ne 0) {
          echo "‚ùå PyInstaller failed with exit code: $LASTEXITCODE"
          exit 1
        }
        
        $exePath = "dist/$exeName.exe"
        if (Test-Path $exePath) {
          $size = (Get-Item $exePath).Length
          $sizeMB = [math]::Round($size / 1MB, 2)
          echo "‚úÖ Build successful! File: $exePath"
          echo "üìä File size: $sizeMB MB"
        } else {
          echo "‚ùå Build failed - executable not found!"
          exit 1
        }
      shell: pwsh

    - name: Test production executable
      run: |
        $exePath = "dist/PDF-Metadata-Tool-${{ steps.version.outputs.VERSION }}.exe"
        
        echo "üß™ Testing production executable (should NOT be in build mode)..."
        
        # Test PE signature
        $signature = Get-Content $exePath -AsByteStream -TotalCount 2
        if ($signature[0] -eq 77 -and $signature[1] -eq 90) {
          echo "‚úÖ Valid PE executable format"
        } else {
          echo "‚ùå Invalid executable format"
          exit 1
        }
        
        # Quick execution test (with timeout)
        try {
          echo "üîÑ Testing executable startup..."
          # Run with --version flag if supported, or timeout after 10 seconds
          $process = Start-Process -FilePath $exePath -ArgumentList "--version" -Wait -PassThru -WindowStyle Hidden -Timeout 10000
          echo "‚úÖ Executable starts successfully"
        } catch {
          echo "‚ö†Ô∏è Executable test completed (timeout expected for GUI apps)"
        }
        
        $fileInfo = Get-Item $exePath
        echo "üìã Final executable details:"
        echo "   Size: $([math]::Round($fileInfo.Length / 1MB, 2)) MB"
        echo "   Created: $($fileInfo.CreationTime)"
      shell: pwsh

    - name: Create Release
      id: create_release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.version.outputs.VERSION }}
        name: PDF Metadata Tool ${{ steps.version.outputs.VERSION }}
        body: |
          ## üöÄ PDF Metadata Tool ${{ steps.version.outputs.VERSION }}
          
          ### üìä Build Information
          - **Version:** ${{ steps.version.outputs.VERSION }}
          - **Built on:** ${{ github.event.head_commit.timestamp }}
          - **Commit:** [${{ github.sha }}](https://github.com/${{ github.repository }}/commit/${{ github.sha }})
          - **Build #:** ${{ github.run_number }}
          - **Trigger:** ${{ github.event_name }}
          
          ### üîß Installation Instructions
          1. üì• Download the executable file below
          2. üèÉ Run the application directly (double-click or from command line)
          3. üîë Enter your license key when prompted
          4. ‚úÖ Start using the PDF Metadata Tool!
          
          ### ‚ú® What's New
          - Fixed BUILD MODE detection - application now runs normally for end users
          - Improved PyInstaller dependency packaging
          - Enhanced error handling and user experience
          
          ### üêõ Troubleshooting
          If you see "BUILD MODE" message:
          - This version should run in normal production mode
          - If you still see build mode, please report the issue
          
          ### üîÑ Auto-Update Feature
          The application automatically checks for updates on startup and will notify you when new versions are available.
          
          ### üõ°Ô∏è System Requirements
          - Windows 10/11 (64-bit recommended)
          - No additional software installation required
          - Valid license key from your license provider
          
          ### üìû Support
          For technical support or license issues, please contact your license provider or visit the license management portal.
        files: ./dist/PDF-Metadata-Tool-${{ steps.version.outputs.VERSION }}.exe
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Notify License Server
      run: |
        $body = @{
          version = "${{ steps.version.outputs.VERSION }}"
          download_url = "https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.VERSION }}/PDF-Metadata-Tool-${{ steps.version.outputs.VERSION }}.exe"
          release_date = Get-Date -Format "yyyy-MM-dd'T'HH:mm:ss'Z'"
          build_number = "${{ github.run_number }}"
          commit_sha = "${{ github.sha }}"
          filename = "PDF-Metadata-Tool-${{ steps.version.outputs.VERSION }}.exe"
          release_url = "https://github.com/${{ github.repository }}/releases/tag/${{ steps.version.outputs.VERSION }}"
        } | ConvertTo-Json -Depth 3
        
        $notification_endpoints = @(
          "https://pdf-license-server-dmyx.onrender.com/api/release-notification"
        )
        
        if ("${{ secrets.LICENSE_SERVER_URL }}" -ne "") {
          $notification_endpoints = @("${{ secrets.LICENSE_SERVER_URL }}/api/release-notification") + $notification_endpoints
        }
        
        $headers = @{
          "Content-Type" = "application/json"
          "User-Agent" = "GitHub-Actions-PDF-Builder/1.0"
        }
        
        if ("${{ secrets.WEBHOOK_SECRET }}" -ne "") {
          $headers["X-GitHub-Token"] = "${{ secrets.WEBHOOK_SECRET }}"
        }
        
        $notification_success = $false
        
        foreach ($endpoint in $notification_endpoints) {
          if ($endpoint -eq "") { continue }
          
          echo "üîî Notifying license server: $endpoint"
          
          try {
            $response = Invoke-RestMethod -Uri $endpoint -Method POST -Body $body -Headers $headers -TimeoutSec 30
            echo "‚úÖ Successfully notified license server!"
            echo "üìã Response: $($response | ConvertTo-Json -Compress)"
            $notification_success = $true
            break
          } catch {
            echo "‚ö†Ô∏è Failed to notify $endpoint : $($_.Exception.Message)"
            continue
          }
        }
        
        echo ""
        echo "üéâ BUILD SUMMARY:"
        echo "================="
        echo "‚úÖ Version: ${{ steps.version.outputs.VERSION }}"
        echo "‚úÖ Download: https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.VERSION }}/PDF-Metadata-Tool-${{ steps.version.outputs.VERSION }}.exe"
        echo "‚úÖ Release: https://github.com/${{ github.repository }}/releases/tag/${{ steps.version.outputs.VERSION }}"
        if ($notification_success) {
          echo "‚úÖ License server notified"
        } else {
          echo "‚ö†Ô∏è License server notification failed (non-critical)"
        }
      shell: pwsh
