name: Build and Release PDF Metadata Tool

on:
  push:
    paths:
      - 'client.py'
    branches: [ main ]
  workflow_dispatch:
    inputs:
      build_client:
        description: 'Build client executable'
        required: false
        default: 'true'
      version_tag:
        description: 'Version tag for release'
        required: false
        default: ''

env:
  PYTHON_VERSION: '3.11'
  APP_NAME: 'PDF-Metadata-Tool'

jobs:
  build:
    name: Build PDF Metadata Tool Executable
    runs-on: windows-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~\AppData\Local\pip\Cache
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
          
    - name: Install system dependencies and upgrade pip
      run: |
        python -m pip install --upgrade pip setuptools wheel
        python -m pip install --upgrade pyinstaller==5.13.2
        echo "‚úÖ Base dependencies installed"
        
    - name: Install application dependencies
      run: |
        python -m pip install aiohttp aiofiles psutil requests
        python -m pip install cryptography pywin32
        echo "‚úÖ Application dependencies installed"
        
    - name: Verify client.py exists
      run: |
        if (Test-Path "client.py") {
          Write-Host "‚úÖ client.py found"
          $content = Get-Content client.py -Head 10
          Write-Host "First 10 lines of client.py:"
          $content | ForEach-Object { Write-Host "  $_" }
        } else {
          Write-Host "‚ùå client.py not found in current directory"
          Write-Host "Current directory contents:"
          Get-ChildItem | ForEach-Object { Write-Host "  $($_.Name)" }
          exit 1
        }
        
    - name: Extract version from client.py
      id: extract_version
      run: |
        $content = Get-Content client.py -Raw
        if ($content -match 'VERSION\s*=\s*["\']([^"\']+)["\']') {
          $version = $matches[1]
          Write-Host "Extracted version: $version"
          echo "version=$version" >> $env:GITHUB_OUTPUT
        } else {
          $timestamp = Get-Date -Format "yyyy.MM.dd.HHmm"
          $version = "v$timestamp"
          Write-Host "No version found, using timestamp: $version"
          echo "version=$version" >> $env:GITHUB_OUTPUT
        }
        
    - name: Create spec file
      run: |
        Write-Host "üî® Creating PyInstaller spec file..."
        
        $specContent = @"
# -*- mode: python ; coding: utf-8 -*-
import sys
from PyInstaller.building.build_main import Analysis, PYZ, EXE

block_cipher = None

a = Analysis(
    ['client.py'],
    pathex=[],
    binaries=[],
    datas=[],
    hiddenimports=[
        'aiohttp',
        'aiofiles', 
        'asyncio',
        'json',
        'hashlib',
        'platform',
        'subprocess',
        'pathlib',
        'tempfile',
        'zipfile',
        'shutil',
        'logging',
        'threading',
        'requests',
        'psutil',
        'cryptography',
        'pkg_resources.extern'
    ],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='${{ env.APP_NAME }}-v${{ steps.extract_version.outputs.version }}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)
"@
        
        $specContent | Out-File -FilePath "build_client.spec" -Encoding UTF8
        Write-Host "‚úÖ Spec file created"
        
    - name: Build executable with PyInstaller
      run: |
        Write-Host "üî® Building executable with PyInstaller..."
        
        # Create dist directory
        if (-not (Test-Path "dist")) {
          New-Item -ItemType Directory -Path "dist"
        }
        
        # Run PyInstaller with spec file
        try {
          pyinstaller build_client.spec --clean --noconfirm --distpath dist --workpath build --specpath .
          Write-Host "‚úÖ Build completed successfully"
        } catch {
          Write-Host "‚ùå Build failed: $_"
          Write-Host "PyInstaller logs:"
          if (Test-Path "build\build_client\warn-build_client.txt") {
            Get-Content "build\build_client\warn-build_client.txt"
          }
          exit 1
        }
        
    - name: Verify build output
      run: |
        $exePath = "dist\${{ env.APP_NAME }}-v${{ steps.extract_version.outputs.version }}.exe"
        if (Test-Path $exePath) {
          $fileInfo = Get-Item $exePath
          Write-Host "‚úÖ Executable created successfully:"
          Write-Host "   Path: $($fileInfo.FullName)"
          Write-Host "   Size: $([math]::Round($fileInfo.Length / 1MB, 2)) MB"
          Write-Host "   Created: $($fileInfo.CreationTime)"
        } else {
          Write-Host "‚ùå Executable not found at expected path: $exePath"
          Write-Host "Contents of dist directory:"
          if (Test-Path "dist") {
            Get-ChildItem -Path "dist" -Recurse | ForEach-Object { Write-Host "  $($_.FullName)" }
          } else {
            Write-Host "  dist directory does not exist"
          }
          exit 1
        }
        
    - name: Test executable (basic check)
      run: |
        $exePath = "dist\${{ env.APP_NAME }}-v${{ steps.extract_version.outputs.version }}.exe"
        Write-Host "üß™ Testing executable..."
        
        try {
          # Test that the executable can start (should exit quickly with --version or similar)
          $process = Start-Process -FilePath $exePath -ArgumentList "--help" -Wait -PassThru -WindowStyle Hidden -ErrorAction SilentlyContinue
          Write-Host "‚úÖ Executable test completed (exit code: $($process.ExitCode))"
        } catch {
          Write-Host "‚ö†Ô∏è Executable test warning: $_"
          Write-Host "This may be normal if the app requires GUI interaction"
        }
        
    - name: Create release using GitHub CLI
      run: |
        $version = "v${{ steps.extract_version.outputs.version }}"
        $exePath = "dist\${{ env.APP_NAME }}-v${{ steps.extract_version.outputs.version }}.exe"
        
        Write-Host "üì¶ Creating GitHub release..."
        
        $releaseBody = @"
## PDF Metadata Tool Professional $version

üîê **Enterprise-grade PDF metadata restoration with secure licensing**

### üöÄ Features
- Advanced PDF metadata processing engine
- Hardware-locked license validation  
- Automatic update notifications
- Professional Material Design UI
- Real-time progress tracking
- Enhanced error handling and logging

### üìã Requirements
- Windows 10/11 (64-bit)
- Valid license key from administrator
- Internet connection for license validation

### üîß Installation
1. Download the executable below
2. Run the application 
3. Enter your license key when prompted
4. Place PDF files in the 'original' folder
5. Processed files will appear in 'processed' folder

### üìß Support
For licensing and technical support, contact: halexandros25@gmail.com
Include your Hardware ID when requesting a license.

### üîê License Server
This client connects to: https://pdf-license-server-dmyx.onrender.com

---
**Built on:** ${{ github.run_started_at }}  
**Commit:** ${{ github.sha }}  
**Build #:** ${{ github.run_number }}
"@
        
        # Create release and upload asset using GitHub CLI
        try {
          gh release create $version $exePath --title "PDF Metadata Tool $version" --notes $releaseBody
          Write-Host "‚úÖ Release created successfully"
        } catch {
          Write-Host "‚ùå Release creation failed: $_"
          exit 1
        }
      env:
        GH_TOKEN: ${{ github.token }}
        
    - name: Update license server
      run: |
        Write-Host "üì° Notifying license server of new release..."
        
        $releaseData = @{
          version = "v${{ steps.extract_version.outputs.version }}"
          download_url = "https://github.com/${{ github.repository }}/releases/tag/v${{ steps.extract_version.outputs.version }}"
          release_date = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ssZ")
          build_number = "${{ github.run_number }}"
          commit_sha = "${{ github.sha }}"
        } | ConvertTo-Json
        
        try {
          $headers = @{
            'Content-Type' = 'application/json'
            'User-Agent' = 'GitHub-Actions-Bot'
          }
          
          Invoke-RestMethod -Uri "https://pdf-license-server-dmyx.onrender.com/api/release-notification" -Method POST -Body $releaseData -Headers $headers -ContentType "application/json" -TimeoutSec 30
          Write-Host "‚úÖ License server notified successfully"
        } catch {
          Write-Host "‚ö†Ô∏è License server notification failed: $_"
          Write-Host "This is not critical - the release was still created successfully"
        }
        
    - name: Cleanup build artifacts
      run: |
        Write-Host "üßπ Cleaning up build artifacts..."
        if (Test-Path "build") {
          Remove-Item -Path "build" -Recurse -Force -ErrorAction SilentlyContinue
          Write-Host "‚úÖ Build directory cleaned"
        }
        if (Test-Path "build_client.spec") {
          Remove-Item -Path "build_client.spec" -Force -ErrorAction SilentlyContinue
          Write-Host "‚úÖ Spec file cleaned"
        }
        
    - name: Build summary
      run: |
        Write-Host ""
        Write-Host "üéâ BUILD COMPLETED SUCCESSFULLY!"
        Write-Host "=================================="
        Write-Host "Version: v${{ steps.extract_version.outputs.version }}"
        Write-Host "Release: https://github.com/${{ github.repository }}/releases/tag/v${{ steps.extract_version.outputs.version }}"
        Write-Host "Download: Available in GitHub release"
        Write-Host "Size: $(Get-Item "dist\${{ env.APP_NAME }}-v${{ steps.extract_version.outputs.version }}.exe" | ForEach-Object { [math]::Round($_.Length / 1MB, 2) }) MB"
        Write-Host ""
        Write-Host "üîó Users can now download the latest version!"
        Write-Host "üì± Existing clients will receive automatic update notifications"
        Write-Host ""

  notify_completion:
    name: Notify Build Completion  
    runs-on: ubuntu-latest
    needs: build
    if: always()
    
    steps:
    - name: Notify success
      if: needs.build.result == 'success'
      run: |
        echo "‚úÖ PDF Metadata Tool build completed successfully!"
        echo "üöÄ New release is now available for download"
        echo "üì± Clients will receive automatic update notifications"
        
    - name: Notify failure
      if: needs.build.result == 'failure'
      run: |
        echo "‚ùå PDF Metadata Tool build failed!"
        echo "üîç Check the build logs for details"
        echo "üõ†Ô∏è Manual intervention may be required"
